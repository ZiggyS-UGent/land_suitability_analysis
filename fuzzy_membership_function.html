<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<style>
body { font-family: Arial; }

.graph-container { margin-bottom: 50px; }

.point {
  fill: red;
  cursor: pointer;
}

.axis { stroke: black; stroke-width: 1; }

.axis-label {
  font-size: 12px;
  text-anchor: middle;
}

.section-title {
  font-size: 16px;
  font-weight: bold;
  margin-bottom: 6px;
}

#summary {
  margin-top: 10px;
  font-family: monospace;
  white-space: pre;
  border: 1px solid #ccc;
  padding: 12px;
  font-size: 16px;
}
</style>
</head>
<body>

<h2>
Select and customize the graphs to display the optimal conditions for each variable for the land use/land cover type ‘arable cropland’.
</h2>

<div id="graphs"></div>

<div>
  <p class="section-title"><strong>Copy the following parameters:</strong></p>
  <div id="summary"></div>
</div>

<script>
const variables = [
  "Soil clay content",
  "Soil organic content",
  "Slope",
  "Soil moisture",
  "Solar exposure"
];

const width = 700, height = 450, padding = 60;
const xMin = 0, xMax = 100, yMin = 0, yMax = 1;
const sigmaMin = 1.0;

const graphObjects = [];

function createGraph(variableName, idSuffix) {

  const container = document.createElement("div");
  container.className = "graph-container";

  const title = document.createElement("div");
  title.className = "section-title";
  title.textContent = variableName;
  container.appendChild(title);

  const selectLabel = document.createElement("label");
  selectLabel.textContent = "Function: ";

  const select = document.createElement("select");
  ["linear","linearInv","gaussian"].forEach(opt=>{
    const o = document.createElement("option");
    o.value=opt; o.textContent=opt;
    select.appendChild(o);
  });

  selectLabel.appendChild(select);
  container.appendChild(selectLabel);

  const svg = document.createElementNS("http://www.w3.org/2000/svg","svg");
  svg.setAttribute("width",width);
  svg.setAttribute("height",height);
  container.appendChild(svg);

  document.getElementById("graphs").appendChild(container);

  let draggingPoint=null;

  let params = {
    linear:[{x:20,y:0},{x:80,y:1}],
    linearInv:[{x:20,y:1},{x:80,y:0}],
    gaussian:[{x:50,y:1},{x:70,y:0.2}]
  };

  function scaleX(x){ return padding + (x-xMin)/(xMax-xMin)*(width-2*padding); }
  function scaleY(y){ return height-padding - (y-yMin)/(yMax-yMin)*(height-2*padding); }
  function unscaleX(px){ return xMin + ((px-padding)/(width-2*padding))*(xMax-xMin); }
  function unscaleY(py){ return yMin + ((height-padding-py)/(height-2*padding))*(yMax-yMin); }

  function drawAxes(){
    svg.innerHTML="";

    // axes lines
    const axes = [
      [scaleX(xMin),scaleY(yMin),scaleX(xMax),scaleY(yMin)],
      [scaleX(xMin),scaleY(yMin),scaleX(xMin),scaleY(yMax)]
    ];
    axes.forEach(a=>{
      const l=document.createElementNS("http://www.w3.org/2000/svg","line");
      l.setAttribute("x1",a[0]); l.setAttribute("y1",a[1]);
      l.setAttribute("x2",a[2]); l.setAttribute("y2",a[3]);
      l.setAttribute("class","axis");
      svg.appendChild(l);
    });

    // X ticks
    for(let i=0;i<=100;i+=20){
      const tick=document.createElementNS("http://www.w3.org/2000/svg","line");
      tick.setAttribute("x1",scaleX(i));
      tick.setAttribute("y1",scaleY(yMin)-5);
      tick.setAttribute("x2",scaleX(i));
      tick.setAttribute("y2",scaleY(yMin)+5);
      tick.setAttribute("class","axis");
      svg.appendChild(tick);

      const label=document.createElementNS("http://www.w3.org/2000/svg","text");
      label.setAttribute("x",scaleX(i));
      label.setAttribute("y",scaleY(yMin)+25);
      label.setAttribute("class","axis-label");
      label.textContent=i;
      svg.appendChild(label);
    }

    // Y ticks (percent)
    for(let i=0;i<=1;i+=0.2){
      const tick=document.createElementNS("http://www.w3.org/2000/svg","line");
      tick.setAttribute("x1",scaleX(xMin)-5);
      tick.setAttribute("y1",scaleY(i));
      tick.setAttribute("x2",scaleX(xMin)+5);
      tick.setAttribute("y2",scaleY(i));
      tick.setAttribute("class","axis");
      svg.appendChild(tick);

      const label=document.createElementNS("http://www.w3.org/2000/svg","text");
      label.setAttribute("x",scaleX(xMin)-25);
      label.setAttribute("y",scaleY(i)+4);
      label.setAttribute("class","axis-label");
      label.textContent=Math.round(i*100)+"%";
      svg.appendChild(label);
    }

    // X axis title (more breathing room)
    const xTitle=document.createElementNS("http://www.w3.org/2000/svg","text");
    xTitle.setAttribute("x",scaleX((xMin+xMax)/2));
    xTitle.setAttribute("y",height-10);
    xTitle.setAttribute("class","axis-label");
    xTitle.textContent=variableName;
    svg.appendChild(xTitle);

    // Y axis title (horizontal with same spacing)
    const yTitle=document.createElementNS("http://www.w3.org/2000/svg","text");
    yTitle.setAttribute("x", scaleX(xMin));
    yTitle.setAttribute("y", padding - 25);
    yTitle.setAttribute("text-anchor","start");
    yTitle.setAttribute("class","axis-label");
    yTitle.textContent="Suitability (%)";
    svg.appendChild(yTitle);
  }

  function computeCurve(type){
    const res=[];
    if(type==="linear"||type==="linearInv"){
      const p=params[type];
      for(let x=0;x<=100;x++){
        let y=(x-p[0].x)/(p[1].x-p[0].x);
        if(type==="linearInv") y=1-y;
        y=Math.max(0,Math.min(1,y));
        res.push({x,y});
      }
    }
    else{
      const peak=params.gaussian[0];
      const side=params.gaussian[1];
      const mu=peak.x;
      let sigma=Math.abs(side.x-mu)/Math.sqrt(-2*Math.log(Math.max(side.y,0.01)));
      sigma=Math.max(sigma,sigmaMin);

      for(let x=0;x<=100;x++){
        let y=Math.exp(-Math.pow(x-mu,2)/(2*sigma*sigma));
        res.push({x,y});
      }
    }
    return res;
  }

  function drawCurve(){
    drawAxes();

    const curvePts=computeCurve(select.value);

    let path="M "+scaleX(curvePts[0].x)+" "+scaleY(curvePts[0].y);
    for(let i=1;i<curvePts.length;i++){
      path+=" L "+scaleX(curvePts[i].x)+" "+scaleY(curvePts[i].y);
    }

    const curve=document.createElementNS("http://www.w3.org/2000/svg","path");
    curve.setAttribute("d",path);
    curve.setAttribute("stroke","black");
    curve.setAttribute("fill","none");
    curve.setAttribute("stroke-width","2");
    svg.appendChild(curve);

    params[select.value].forEach((p,i)=>{
      const c=document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx",scaleX(p.x));
      c.setAttribute("cy",scaleY(p.y));
      c.setAttribute("r",8);
      c.setAttribute("class","point");
      c.addEventListener("pointerdown",()=>draggingPoint=i);
      svg.appendChild(c);
    });

    updateSummary();
  }

  svg.addEventListener("pointermove",e=>{
    if(draggingPoint===null) return;

    const rect=svg.getBoundingClientRect();
    let x=Math.max(0,Math.min(100,unscaleX(e.clientX-rect.left)));
    let y=Math.max(0,Math.min(1,unscaleY(e.clientY-rect.top)));

    const type=select.value;

    if(type==="gaussian"){
      if(draggingPoint===0){
        params.gaussian[0]={x:x,y:1};
        if(params.gaussian[1].x<x+0.1) params.gaussian[1].x=x+0.1;
      } else {
        if(x<params.gaussian[0].x+0.1) x=params.gaussian[0].x+0.1;
        params.gaussian[1]={x:x,y:y};
      }
    }

    if(type==="linear"||type==="linearInv"){
      if(draggingPoint===0) params[type][0].x=x;
      else params[type][1].x=x;
    }

    drawCurve();
  });

  svg.addEventListener("pointerup",()=>draggingPoint=null);
  svg.addEventListener("pointerleave",()=>draggingPoint=null);
  select.onchange=drawCurve;

  graphObjects.push({
    variable:variableName,
    getParameters(){
      const type=select.value;
      if(type==="gaussian"){
        const peak=params.gaussian[0];
        const side=params.gaussian[1];
        let sigma=Math.abs(side.x-peak.x)/Math.sqrt(-2*Math.log(Math.max(side.y,0.01)));
        sigma=Math.max(sigma,sigmaMin);
        return `Gaussian (${peak.x.toFixed(1)}, ${sigma.toFixed(1)})`;
      }
      return `${type} (${params[type][0].x.toFixed(1)}, ${params[type][1].x.toFixed(1)})`;
    }
  });

  drawCurve();
}

variables.forEach((v,i)=>createGraph(v,i));

function updateSummary(){
  const summary=document.getElementById("summary");
  let txt="";
  graphObjects.forEach(g=>{
    txt+=`${g.variable}: ${g.getParameters()}\n`;
  });
  summary.textContent=txt;
}
</script>
</body>
</html>